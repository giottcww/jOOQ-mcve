package org.jooq.mcve.test.kotlin.postgres

import kotlinx.coroutines.reactive.awaitFirst
import kotlinx.coroutines.reactive.awaitFirstOrNull
import kotlinx.coroutines.runBlocking
import org.jooq.DSLContext
import org.jooq.kotlin.coroutines.transactionCoroutine
import org.jooq.mcve.Main
import org.jooq.mcve.kotlin.postgres.tables.references.TEST
import org.junit.After
import org.junit.Before
import org.junit.jupiter.api.Assertions
import org.junit.jupiter.api.Test
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.boot.test.autoconfigure.jdbc.AutoConfigureTestDatabase
import org.springframework.boot.test.context.SpringBootTest
import org.springframework.test.context.DynamicPropertyRegistry
import org.springframework.test.context.DynamicPropertySource
import org.testcontainers.containers.PostgreSQLContainer
import org.testcontainers.containers.PostgreSQLR2DBCDatabaseContainer
import org.testcontainers.junit.jupiter.Container
import org.testcontainers.junit.jupiter.Testcontainers


@SpringBootTest(classes = [Main::class])
@AutoConfigureTestDatabase(replace = AutoConfigureTestDatabase.Replace.NONE)
@Testcontainers
class KotlinTest {
    companion object {

        @Container
        private val db = PostgreSQLContainer("postgres:latest")
//        @Container
//        private val _db = PostgreSQLR2DBCDatabaseContainer(db)

        @DynamicPropertySource
        @JvmStatic
        fun registerDynamicProperties(registry: DynamicPropertyRegistry) {
            registry.add("spring.datasource.url"){ db.jdbcUrl }
            registry.add("spring.datasource.username"){ db.username }
            registry.add("spring.datasource.password"){ db.password }
            registry.add("spring.datasource.schema"){ db.databaseName }

//            registry.add("spring.r2dbc.initialization-mode") { "always" }
//            registry.add("spring.r2dbc.url") { "r2dbc:postgresql://${db.host}:${db.getMappedPort(PostgreSQLContainer.POSTGRESQL_PORT)}/${db.databaseName}" }
//            registry.add("spring.r2dbc.username") { db.username }
//            registry.add("spring.r2dbc.password") { db.password }
//            registry.add("spring.r2dbc.schema") { "public" }
//            registry.add("spring.r2dbc.pool.initial-size") { "10" }
//            registry.add("spring.r2dbc.pool.min-idle") { "10" }
//            registry.add("spring.r2dbc.pool.max-size") { "200" }
//
//            registry.add("spring.r2dbc.pool.enabled") { true }
//            registry.add("spring.r2dbc.pool.max-idle-time") { "15s" }
//            registry.add("spring.r2dbc.pool.max-create-connection-time") { "30s" }
//            registry.add("spring.r2dbc.pool.max-acquire-time") { "60s" }
//            registry.add("spring.r2dbc.pool.max-validation-time") { "30s" }
//            registry.add("spring.r2dbc.pool.validation-query") { "SELECT 1" }

            registry.add("spring.flyway.url") { db.jdbcUrl }
            registry.add("spring.flyway.user") { db.username }
            registry.add("spring.flyway.password") { db.password }
            registry.add("spring.flyway.baseline-on-migrate") { true }
            registry.add("spring.flyway.baseline-version") { 0 }
        }
    }


    @Autowired
    private lateinit var ctx: DSLContext

    @Before
    fun setup() {
        ctx.delete(TEST).execute()
    }

    @After
    fun after() {}

    @Test
    fun mcveTest() {

        try {
            runBlocking {
                ctx.transactionCoroutine { c ->
                    c.dsl()
                        .insertInto(TEST)
                        .columns(TEST.CD)
                        .values(43)
                        .awaitFirst()
                    throw RuntimeException()
                }
            }
        } catch(ex : Exception){ /*ignored */ }

        runBlocking {
            var record = ctx.selectFrom(TEST)
                .where(TEST.CD.eq(43))
                .awaitFirstOrNull()
            Assertions.assertNull(record?.id)
        }
    }
}